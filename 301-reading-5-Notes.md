# **Reading Assignment 5 - Heroku Deployment**

1. ## Setup Process
  + ### Installation
    +  In the terminal: `npm install heroku`
    + When installation completes, you can use the heroku command from your terminal.
    + Use the heroku login command to log in to the Heroku CLI:
    + `heroku login` - This command opens your web browser to the Heroku login page. If your browser is already logged in to Heroku, simply click the Log in button displayed on the page.
    + Before you continue, check that you have the prerequisites installed properly. Type each command below and make sure it displays the version you have installed:
      + `node --version` - npm is installed with Node, so check that it’s there. 
      + `npm --version` - If you don’t have it, install a more recent version of Node.
      + `git --version` - Now check that you have git installed. If not, install it and test again.
    + **Prepare the App**  
      + To clone a local version of the sample application that you can then deploy to Heroku, execute the following commands in your local command shell or terminal:
        + `git clone https://github.com/heroku/node-js-getting-started.git`
        + `cd node-js-getting-started`
    + **Deploy the App**
      + Create an app on Heroku, which prepares Heroku to receive your source code.
      + `heroku create`
      + When you create an app, a git remote (called heroku) is also created and associated with your local git repository.Heroku generates a random name (in this case sharp-rain-871) for your app, or you can pass a parameter to specify your own app name.
      + Now deploy your code:
      + `git push heroku main`
      + The application is now deployed. Ensure that at least one instance of the app is running:
        + `heroku ps:scale web=1`
      + Now visit the app at the URL generated by its app name. As a handy shortcut, you can open the website as follows:
      + `heroku open`
    + **Viewing Logs**
      + Heroku treats logs as streams of time-ordered events aggregated from the output streams of all your app and Heroku components, providing a single channel for all of the events. View information about your running app using one of the logging commands:
        + `heroku logs --tail`
      + Reference your jQuery file by using this html script before your closing `</body>` tag: `<script src="j s/ jquery-1 . 11. 0 .js "></script>`
      + Basic Example: `$(' :header').addClass('headline'); $(' li : lt(3) ').hide(). fadeln(lSOO); $('li').on('click', function() {$(this) . remove();`
    + **Define a Procfile**
     + Use a Procfile, a text file in the root directory of your application, to explicitly declare what command should be executed to start your app. The Procfile in the example app you deployed looks like this:
      + `web: node index.js`
    + **Scale the App**
      + Right now, your app is running on a single web dyno. Think of a dyno as a lightweight container that runs the command specified in the Procfile. You can check how many dynos are running using the ps command:
        + `heroku ps`
      + Scaling an application on Heroku is equivalent to changing the number of dynos that are running. Scale the number of web dynos to zero:
        + `heroku ps:scale web=0`
      + Access the app again by hitting refresh on the web tab, or heroku open to open it in a web tab. You will get an error message because you no longer have any web dynos available to serve requests. Scale it up again:
        + `heroku ps:scale web=1`
    + **Declare App Dependencies**
      + Heroku recognizes an app as Node.js by the existence of a package.json file in the root directory. For your own apps, you can create one by running `npm init --yes`
      + The package.json file determines both the version of Node.js that will be used to run your application on Heroku, as well as the dependencies that should be installed with your application. Run this command in your local directory to install the dependencies, preparing your system for running the app locally: 
        + `npm install`
    + **Run the app locally**
      + Now start your application locally using the heroku local command, which was installed as part of the Heroku CLI:
        + `heroku local web`
      + Now test locally:
        + `npm install`
        + `heroku local`
      + Now deploy. Almost every deploy to Heroku follows this same pattern. First, add the modified files to the local git repository:
        + `git add`
      + Now commit the changes to the repository:
        + `git commit -m "update on status of app"`
      + Now deploy, just as you did previously:
        + `git push heroku main`
    + **Provision add-ons**
      + Add-ons are third-party cloud services that provide out-of-the-box additional services for your application, from persistence through logging to monitoring and more.
      + By default, Heroku stores 1500 lines of logs from your application. However, it makes the full log stream available as a service - and several add-on providers have written logging services that provide things such as log persistence, search, and email and SMS alerts.
      + In this step you will provision one of these logging add-ons, Papertrail. Provision the papertrail logging add-on:
        + `heroku addons:create papertrail`
      + The add-on is now deployed and configured for your application. You can list add-ons for your app like so:
        + `heroku addons`
      + To see this particular add-on in action, visit your application’s Heroku URL a few times. Each visit will generate more log messages, which should now get routed to the papertrail add-on. Visit the papertrail console to see the log messages:
        + `heroku addons:open papertrail`
    + **Start a console**
      + To get a real feel for how dynos work, you can create another one-off dyno and run the bash command, which opens up a shell on that dyno. You can then execute commands there. Each dyno has its own ephemeral filespace, populated with your app and its dependencies - once the command completes (in this case, bash), the dyno is removed.
        + `heroku run bash`
    + **Define config vars**
      + Heroku lets you externalize configuration - storing data such as encryption keys or external resource addresses in config vars.
      + At runtime, config vars are exposed as environment variables to the application. For example, modify index.js so that it introduces a new route, /times, that repeats an action depending on the value of the TIMES environment variable. Under the existing get() call, add another:
        + `.get('/times', (req, res) => res.send(showTimes()))`
    + **.text()**
      + When this method is used to retrieve the text from a jQuery selection, it returns the content from every element in the jQuery selection, along with the text from any descendants.
      + For example, `$('ul').text();` will return this:
fresh figs
pine nuts
honey
balsamic vinegar
      + Whereas `$('li').text();` will return this:
fresh figspine nutshoneybalsamic vinegar
      
2. ## 6 Reasonfor Paired Programming
  + 1. **Greater efficiency**
    + It is a common misconception that pair programming takes a lot longer and is less efficient. In reality, when two people focus on the same code base, it is easier to catch mistakes in the making. Research indicates that pair programing takes slightly longer, but produces higher-quality code that doesn’t require later effort in troubleshooting and debugging (let alone exposing users to a broken product). So, in the long-run, it’s often actually more efficient than two people working on separate features. When coming up with ideas and discussing solutions out loud, two programmers may come to a solution faster than one programmer on their own. Also, when the pair is stuck, both programmers can research the problem and reach a solution faster. Researches also identified pairing enhances technical skills, team communication, and even enjoyability of coding in the workplace.
  + 2. **Engaged collaboration**
    + When two programmers focus on the same code, the experience is more engaging and both programmers are more focused than if they were working alone. It is harder to procrastinate or get off track when someone else is relying on you to complete the work. Popping open your Facebook timeline is just that less enticing when someone else is looking at your screen.
    + Another important aspect of learning to program is knowing when to ask for help. We advise our students to spend no more than fifteen minutes stuck on a problem before asking a teaching assistant or instructor for help. When developers pair program, they rely more on each other and can often find a solution together without needing to ask for additional help. Ultimately, this boosts overall confidence.
  + 3. Learning from fellow students
    + Everyone has a different approach to problem solving; working with a teammate can expose developers to techniques they otherwise would not have thought of. If one developer has a unique approach to a specific problem, pair programming exposes the other developer to a new solution.
    + Often times, the developers in a pairing have different skill sets. If one programmer is more experienced in a certain skill, they can teach a student who is less familiar with that area. The less experienced developer benefits from the experienced developer’s knowledge and guidance, and the latter benefits from explaining the topic in their own words, further solidifying their own understanding.
  + **4. Social skills**
    + Pair programming is great for improving social skills. When working with someone who has a different coding style, communication is key. This can become more difficult when two programmers have different personalities. Pair programming not only improves programming skills, but can also help programmers develop their interpersonal skills. When just grabbing the keyboard and taking over isn’t an option, getting good at finding the right words is a skill unto itself.
    + This has long-term career impacts. As much as employers want strong programmers, they know it’s essential to hire people who can work well with others.
  + **5. Job interview readiness**
A common step in many interview processes involves pair programming between a current employee and an applicant, either in person or through a shared screen. They will carry out exercises together, such as code challenges, building a project or feature, or debugging an existing code base. By doing so, companies can get a better feel for how an applicant will fit into the team and their collaboration style.
    + For most roles, the ability to work with and learn from others and stellar communication skills are as (or more!) important to a company than specific technical skills. Pair programming strengthens all of those skills.
  + **6. Work environment readiness**
    + Many companies that utilize pair programing expect to train fresh hires from CS-degree programs on how they operate to actually deliver a product. Code Fellows graduates who are already familiar with how pairing works can hit the ground running at a new job, with one less hurdle to overcome.
